#ifndef CERBERUS_CERBERUS_YACC_HELPER_HPP
#define CERBERUS_CERBERUS_YACC_HELPER_HPP

#include "Cerberus_lexer.hpp"
#include <cerberus/analyzation/parser/tree.hpp>
#include <cerberus/math.hpp>
#include <cerberus/types.h>

namespace CL {
    using namespace cerb;
    namespace cap    = cerb::analysis::parser;
    using token_t    = typename CerberusLexer<>::token_t;
    using ParserNode = cap::ParserNode<token_t>;

    CerberusLexerTemplate struct CerberusLexerImpl final : public CerberusLexer<>
    {
        CerberusLexerAccess;
        Vector<token_t> m_tokens{};

        constexpr auto yield(const token_t &token) -> bool override
        {
            m_tokens.emplace_back(token);
            return true;
        }

        constexpr auto error(const item_t &item, const string_view_t &repr)
            -> void override
        {
            analysis::basic_lexical_error(
                item, repr, "Unable to find suitable dot item for: ");
        }

        constexpr auto syntax_error(token_t *token) -> void
        {
            analysis::basic_syntax_error(*head(), token->repr, "Syntax error: ");
        }

        constexpr auto finish() -> void override
        {}
    };

    struct Parser
    {
        size_t current_token_id{};
        token_t *current_token;
        CerberusLexerImpl<> cerberus_lexer{};
        ParserNode *global_view_node{ ParserNode::construct_node(
            global_view_token) };

        constexpr static CL::token_t statement_token = { "Parser statements",
                                                         CerberusLexerItem::STMT,
                                                         {},
                                                         {} };

        constexpr static CL::token_t auto_token = {
            "Auto type generated by compiler",
            CerberusLexerItem::BUILTIN_AUTO_T,
            {},
            {}
        };

        constexpr static CL::token_t global_view_token = {
            "Global view, where functions and global variables are located",
            CerberusLexerItem::GLOBAL_VIEW,
            {},
            {}
        };

        static auto new_statement()
        {
            return ParserNode::construct_node(statement_token);
        }

        static auto new_auto_token()
        {
            return ParserNode::construct_node(auto_token);
        }

        auto next_token() -> token_t *
        {
            current_token = &cerberus_lexer.m_tokens[current_token_id++];
            return current_token;
        }

        auto operator()() const -> token_t *
        {
            return current_token;
        }

        auto print()
        {
            ParserNode::print(global_view_node);
        }

        constexpr Parser()  = default;
        constexpr ~Parser() = default;
    };

    inline Parser parser{};
}// namespace CL

extern "C" int yylex(void);
extern "C" void yyerror(const char *message);

#endif /* CERBERUS_CERBERUS_YACC_HELPER_HPP */
